"""
Интроспекция - способность программы проверять тип и свойство обьекта во время выполнения
Рефлексия - способность программы манипулировать значениями, свойствами и/или методами в процессе выполнения

"""
# isinstance() можем послать любой обьект и он скажет  является ли обьект принадлежащий классу
# Создан ли этот обьект на базе этого класса

"""
Декораторы - обертки которые дают нам возможность изменить поведение функции, не меняя ее код
например я хочу перед запуском функции выходило какое то сообщение, которое содержит
 необходимую нам информацию
"""
# import functools
# import time  # декоратор позволяет определить сколько бежала функция


# @timer - запускает декоратор
def func():
    print("Привет")


# @staticmethod - используется для создания метода, который ничего не знает о классе  или обьекта
# это как обычная функция определенной внутри классса, которая не имеет доступа к экземпляру
# ее можно вызывать без создания экземпляра класса

# Пример

class Person:
    @staticmethod
    def is_adult(age):
        if age > 18:
            return True
        else:
            return False


print(Person.is_adult(19))  # выведeт True без создания экземплдяра класса Person

# @classmethod - это метод который получает класс в качестве первого аргумета и имеет доступ ко всем атрибутам
# класса, не требует создания обьекта

"""
1. Кит OOP - Наследование
2. Кит  Инкапсуляция - скрытие внутренней реализации от других компонентов , доступ к скрытой информации
не напрямую а спомощью методов для чтения( геттер) и изменения ( сеттер) уё значения 
Инкапсуляция  - ограничение доступа к составляющим обьекта ( метододов  и переменным )
Некоторые компоненты доступны только внутри класса
Есть две стороны одна сторона называется Эксес модифайл прайвет и паблик и вторая сторона 
как мы получаем контролируем изменение либо deчтение наших атрибутов. можно имплеминтировать двумя способами
создание гетеров и сетеров 
"""


class Person:
    def __init__(self):
        self._name = ""

    def getter_name(self):  # Создание геттера  читает имя
        return self._name

    def setter_name(self, value):
        self._name = value


class Person1:
    def __init__(self, birth):
        self._name = ""
        self.birth = birth

    @property  # получает чтение  через экземпляр класса Person1.getter_name
    def getter_name(self):  # Создание геттера  читает имя
        return self._name

    @getter_name.setter  # Позволяет изменить через экземпляр класса person1.setter_name("Фдулы")
    def setter_name(self, value): # Создание сеттера
        self._name = value

    @property
    def age(self):
        return 2020 - self.birth


if __name__ == '__main__':
    person1 = Person()
    print(person1.setter_name("Фдулы"))
    print(person1.getter_name())
    person = Person1()
    person.setter_name = "Bentsi"
    print(person.getter_name)




